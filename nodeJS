import express from "express";
import mysql from "mysql2/promise";
import cors from "cors";

const app = express();
const PORT = process.env.PORT || 8000;
app.use(express.json());
app.use(cors());

(async () => {
    try {
        const db = await mysql.createPool({
            host: "localhost", 
            user: "root",     
            password: "passwd",
            database: "mayoApp",
            waitForConnections: true,
            connectionLimit: 10,
            queueLimit: 0,
        });
        console.log("Connected to the database");

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.get('/api/students', async (req, res) => {
            const year = req.headers['year'];
            const className = req.headers['class'];
            const section = req.headers['section'];
            
            if (!year || !className || !section) {
                return res.status(400).json({
                    message: "Missing required headers. Please provide 'year', 'class', and 'section'."
                });
            }

            if (isNaN(year) || isNaN(className) || !section.trim()) {
                return res.status(400).json({
                    message: "Invalid header values. 'year' and 'class' should be numbers, and 'section' cannot be empty."
                });
            }

            try {
                const query = `
                    SELECT s.name 
                    FROM students s 
                    JOIN students_records sc ON s.id = sc.student_id 
                    WHERE sc.year = ? AND sc.class = ? AND sc.section = ?
                `;

                const [results] = await db.execute(query, [year, className, section]);

                if (results.length === 0) {
                    return res.status(404).json({ message: 'No students found for the given year, class, and section.' });
                }

                return res.status(200).json({ Students: results });
            } catch (err) {
                console.error(err);
                return res.status(500).json({ message: 'Server error' });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.post('/api/students', async (req, res) => {
            const year = req.headers['year'];
            const className = req.headers['class'];
            const section = req.headers['section'];
            const studentName = req.body.studentName;
            if (!year || !className || !section || !studentName) {
                return res.status(400).json({
                    message: "Missing required headers. Please provide 'year', 'class', 'section' and 'studentName'."
                });
            }
            if (isNaN(year) || isNaN(className) || !section.trim() || !studentName.trim()) {
                return res.status(400).json({
                    message: "Invalid header values. 'year' and 'class' should be numbers, and 'section' cannot be empty."
                });
            }
            try {
                const insertStudentQuery = `
                    INSERT INTO students (id, name)
                    SELECT COALESCE(MAX(id), 0) + 1, ? FROM students`;
                await db.execute(insertStudentQuery, [studentName]);
                const [newStudentIdRow] = await db.execute('SELECT MAX(id) AS newId FROM students');
                const newStudentId = newStudentIdRow[0].newId;
                const insertRecordQuery = `
                    INSERT INTO students_records (id, student_id, class, section, year)
                    SELECT COALESCE(MAX(id), 0) + 1, ?, ?, ?, ? FROM students_records`;
                await db.execute(insertRecordQuery, [newStudentId, className, section, year]);
                return res.status(201).json({
                    message: "Student and record inserted successfully"
                });
            } catch (error) {
                console.error('Error during student insertion:', error);
                return res.status(500).json({
                    message: "An error occurred while inserting student and record.",
                    error: error.message
                });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.get("/api/report_outcomes", async (req, res) => {
            const year = req.headers["year"];
            const subject = req.headers["subject"];

            if (!year || !subject) {
                return res.status(400).json({
                    message: "Missing required headers. Please provide 'year' and 'subject'.",
                });
            }

            if (isNaN(year) || !subject.trim()) {
                return res.status(400).json({
                    message: "Invalid header values. 'year' should be a number, and 'subject' cannot be empty.",
                });
            }

            try {
                const query = `
            SELECT id, name 
            FROM report_outcomes 
            WHERE year = ? AND subject = ?
            `;
                const [results] = await db.execute(query, [year, subject]);

                if (results.length === 0) {
                    return res.status(404).json({ message: "No report outcomes found for the given year and subject." });
                }

                res.status(200).json({ ro: results });
            } catch (err) {
                console.error("Error fetching report outcomes:", err);
                res.status(500).json({ message: "Server error" });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.post("/api/learning_outcomes", async (req, res) => {
            const { year, quarter, subject } = req.headers;
            const { name } = req.body;
        
            if (!year || !quarter || !subject || !name) {
                return res.status(400).json({
                    message: "Missing required fields: year, quarter, subject (headers) or name (body).",
                });
            }
            try {
                const [maxIdRow] = await db.execute('SELECT MAX(id) AS maxId FROM learning_outcomes');
                const newId = (maxIdRow[0].maxId || 0) + 1; 
        
                const query = `
                INSERT INTO learning_outcomes (id, name, year, quarter, subject) 
                VALUES (?, ?, ?, ?, ?)
                `;
                const [result] = await db.execute(query, [newId, name, year, quarter, subject]);
        
                res.status(201).json({
                    message: "Learning outcome added successfully",
                    insertedId: newId, // Respond with the manually generated ID
                });
            } catch (err) {
                console.error("Error inserting learning outcome:", err);
                res.status(500).json({ message: "Server error", error: err.message });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.get("/api/learning_outcomes", async (req, res) => {
            const { year, subject, quarter } = req.headers;

            if (!year || !subject || !quarter) {
                return res.status(400).json({ message: "Missing required headers: year, subject, or quarter" });
            }

            try {
                const query = `
            SELECT id, name 
            FROM learning_outcomes 
            WHERE year = ? AND subject = ? AND quarter = ?
            `;
                const [results] = await db.execute(query, [year, subject, quarter]);

                if (results.length === 0) {
                    return res.status(404).json({ message: "No learning outcomes found for the provided filters" });
                }

                res.status(200).json(results);
            } catch (err) {
                console.error("Error fetching learning outcomes:", err);
                res.status(500).json({ message: "Internal server error" });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.get('/api/assessment_criterias', async (req, res) => {
            const { subject, year, quarter } = req.headers; // Extract headers

            console.log(`Subject: ${subject}, Year: ${year}, Quarter: ${quarter}`);

            // Validate input
            if (!subject || !year || !quarter) {
                return res.status(400).json({
                    message: 'Invalid input. Subject, Year, and Quarter are required in the headers.',
                });
            }

            try {
                // SQL query to fetch assessment_criterias based on filters
                const query = `
                    SELECT id, name, max_marks
                    FROM assessment_criterias
                    WHERE subject = ? AND year = ? AND quarter = ?
                `;

                // Execute the query
                const [results] = await db.execute(query, [subject, year, quarter]);

                // Check if results are found
                if (results.length === 0) {
                    return res.status(404).json({
                        message: 'No assessment criterias found for the given filters.',
                    });
                }

                // Return the filtered data
                return res.status(200).json({
                    message: 'Assessment criterias retrieved successfully',
                    assessments: results,
                });
            } catch (err) {
                console.error('Error retrieving assessment criterias:', err);

                return res.status(500).json({
                    message: 'Server error while fetching assessment criterias',
                    error: err.message,
                });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.post('/api/assessment_criterias', async (req, res) => {
            const { year, quarter, subject } = req.headers; 
            const { max_marks, name } = req.body; 

            // Validate required fields
            if (!year || !quarter || !subject || !max_marks || !name) {
                return res.status(400).json({
                    message: 'Missing required fields. Ensure year, quarter, subject (headers), and max_marks, name (body) are provided.',
                });
            }

            try {
                // SQL query to insert data into the table
                const insertQuery = `
                    INSERT INTO assessment_criterias (name, max_marks, year, quarter, subject)
                    VALUES (?, ?, ?, ?, ?)
                `;

                // Execute the query
                const [result] = await db.execute(insertQuery, [
                    name,
                    max_marks,
                    year,
                    quarter,
                    subject,
                ]);

                // Return success response
                return res.status(201).json({
                    message: 'Assessment criterion added successfully',
                    insertedId: result.insertId, // Return the ID of the inserted record
                });
            } catch (err) {
                console.error('Error inserting assessment criteria:', err);

                // Handle database-specific errors
                if (err.code === 'ER_DUP_ENTRY') {
                    return res.status(409).json({
                        message: 'Duplicate entry. This assessment criterion already exists.',
                    });
                }

                return res.status(500).json({
                    message: 'Server error while inserting assessment criteria',
                    error: err.message,
                });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.post("/api/ac_scores", async (req, res) => {
            try {
            // Extracting headers
            const { year, quarter, subject } = req.headers;
        
            // Extracting obtained marks from the body
            const { obtained_marks, student_id, ac_id } = req.body;
        
            // Input validation
            if (!obtained_marks) {
                return res.status(400).json({ error: "obtained_marks, student_id and ac_id is required in the body" });
            }
            if (!student_id || !ac_id) {
                return res.status(400).json({ error: "year, quarter, subject are required in the headers" });
            }
        
            // Fetch the assessment criteria using ac_id
            const [criteriaRows] = await db.query(
                "SELECT max_marks FROM assessment_criterias WHERE id = ? AND subject = ? AND quarter = ? AND year = ?",
                [ac_id, subject, quarter, year]
            );
        
            // If no matching criteria is found
            if (criteriaRows.length === 0) {
                return res.status(404).json({ error: "Assessment criteria not found for the given parameters" });
            }
        
            // Fetching max_marks for normalization
            const max_marks = criteriaRows[0].max_marks;
        
            // Calculate normalized marks
            const normalized_marks = obtained_marks / max_marks;
        
            // Insert normalized score into ac_scores table
            const [result] = await db.query(
                "INSERT INTO ac_scores (student_id, ac_id, value) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE value = ?",
                [student_id, ac_id, normalized_marks, normalized_marks]
            );
        
            // Respond with success message
            res.status(201).json({
                message: "Normalized score saved successfully"});
            } catch (error) {
            console.error("Error adding normalized score:", error.message);
            res.status(500).json({ error: "Internal Server Error" });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.get('/api/ac_scores', async (req, res) => {
            const { student_id, ac_id } = req.headers; // Extract headers

            console.log(`Fetching score for Student ID: ${student_id}, Assessment Criteria ID: ${ac_id}`);

            // Validate input
            if (!student_id || !ac_id) {
                return res.status(400).json({
                    message: 'Invalid input. Student ID (student_id) and Assessment Criteria ID (ac_id) are required.',
                });
            }

            try {
                // Query to fetch the score
                const query = `
                    SELECT student_id, ac_id, value
                    FROM ac_scores
                    WHERE student_id = ? AND ac_id = ?
                `;
                const [results] = await db.execute(query, [student_id, ac_id]);

                if (results.length === 0) {
                    // No record found
                    return res.status(404).json({
                        message: 'No score found for the given Student ID and Assessment Criteria ID.',
                    });
                }

                // Return the score
                return res.status(200).json({
                    message: 'Score fetched successfully.',
                    score: results[0], // Return the first (and only) record
                });
            } catch (err) {
                console.error('Error fetching score:', err);

                return res.status(500).json({
                    message: 'Server error while fetching score.',
                    error: err.message,
                });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        const priorityValues = {
            h: 0.5,
            m: 0.3,
            l: 0.2,
        };
        
        app.post("/api/lo_ac_mapping", async (req, res) => {
            try {
                // Extract headers
                const lo_id = req.headers["lo_id"];
                const subject = req.headers["subject"];
                const quarter = req.headers["quarter"];
                const year = req.headers["year"];
                const student_id = req.headers["student_id"]; // Student ID must be passed in headers
        
                // Extract and validate data from the request body
                const { data } = req.body; // Data should be an array with each element containing ac_id and priority
                if (!data || !Array.isArray(data) || data.length === 0) {
                    return res
                        .status(400)
                        .json({ error: "Invalid data format. Expected an array of objects with ac_id and priority." });
                }
        
                // Validate priority values
                const validPriorities = ["h", "m", "l"];
                for (const item of data) {
                    const { priority } = item;
                    if (!validPriorities.includes(priority)) {
                        return res.status(400).json({
                            error: `Invalid priority value '${priority}'. Priority must be one of: 'h', 'm', or 'l'.`,
                        });
                    }
                }
        
                // Validate `lo_id`
                const [loRows] = await db.query(`SELECT id AS lo_id FROM learning_outcomes WHERE id = ?`, [lo_id]);
                if (loRows.length === 0) {
                    return res.status(404).json({ error: "Invalid lo_id provided in the headers." });
                }
        
                // Validate `student_id`
                const [studentRows] = await db.query(`SELECT id AS student_id FROM students WHERE id = ?`, [student_id]);
                if (studentRows.length === 0) {
                    return res.status(404).json({ error: "Invalid student_id provided in the headers." });
                }
        
                // Extract ac_ids from the request data
                const inputAcIds = data.map((item) => item.ac_id);
        
                // Validate provided ac_ids
                const [validAcRows] = await db.query(
                    `SELECT id AS ac_id FROM assessment_criterias WHERE id IN (?) AND subject = ? AND quarter = ? AND year = ?`,
                    [inputAcIds, subject, quarter, year]
                );
        
                const validAcIds = validAcRows.map((row) => row.ac_id);
                if (validAcIds.length !== inputAcIds.length) {
                    return res
                        .status(404)
                        .json({ error: "Some provided ac_ids are invalid or do not match the filters." });
                }
        
                // Calculate priority occurrences
                let hOccurrence = 0,
                    mOccurrence = 0,
                    lOccurrence = 0;
                data.forEach((item) => {
                    if (item.priority === "h") hOccurrence++;
                    else if (item.priority === "m") mOccurrence++;
                    else if (item.priority === "l") lOccurrence++;
                });
        
                // Calculate the total denominator for weights
                const totalDenominator =
                    hOccurrence * priorityValues.h + mOccurrence * priorityValues.m + lOccurrence * priorityValues.l;
                if (totalDenominator === 0) {
                    return res
                        .status(400)
                        .json({ error: "The total denominator for weight calculation is zero. Check input values." });
                }
        
                // Insert weights into `lo_ac_mapping`
                const loAcMappingPromises = data.map(async (item) => {
                    const { ac_id, priority } = item;
                    let weight = 0;
        
                    // Calculate weight for the current ac_id
                    if (priority === "h") weight = priorityValues.h / totalDenominator;
                    else if (priority === "m") weight = priorityValues.m / totalDenominator;
                    else if (priority === "l") weight = priorityValues.l / totalDenominator;
        
                    // Insert or update weights in the database
                    await db.query(
                        "INSERT INTO lo_ac_mapping (lo_id, ac_id, weight) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE weight = ?",
                        [lo_id, ac_id, weight, weight]
                    );
        
                    return { ac_id, weight }; // Return mapping for later use
                });
        
                // Resolve all weight calculations
                const mappings = await Promise.all(loAcMappingPromises);
        
                // Calculate lo_scores
                let loScore = 0;
                for (const mapping of mappings) {
                    const { ac_id, weight } = mapping;
        
                    // Fetch `value` from `ac_scores` for the current ac_id
                    const [acScoreRows] = await db.query(
                        "SELECT value FROM ac_scores WHERE ac_id = ?",
                        [ac_id]
                    );
        
                    if (acScoreRows.length === 0) {
                        throw new Error(`ac_scores is missing for ac_id: ${ac_id}`);
                    }
        
                    const { value } = acScoreRows[0];
                    loScore += weight * value; // Accumulate lo_scores
                }
        
                // Insert the calculated lo_scores into the `lo_scores` table
                await db.query(
                    "INSERT INTO lo_scores (lo_id, student_id, value) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE value = ?",
                    [lo_id, student_id, loScore, loScore]
                );
        
                // Success response with lo_scores
                res.status(201).json({
                    message: "LO and AC mapping with weights saved successfully",
                    lo_score: loScore, // Include lo_scores in the response
                });
            } catch (error) {
                console.error("Error mapping LO and AC:", error.message);
                if (error.message.includes("ac_scores is missing")) {
                    return res.status(400).json({ error: error.message });
                }
                res.status(500).json({ error: "Internal Server Error" });
            }
        });
        
//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.post("/api/ro_lo_mapping", async (req, res) => {
            try {
                // Extract filters from headers
                const { subject, year, ro_id } = req.headers;
        
                // Validation check for ro_id
                if (!ro_id) {
                    return res.status(400).json({
                        error: "ro_id header is required.",
                    });
                }
        
                // Extract data from the body (JSON)
                const { data } = req.body; // Array with each element containing lo_id and priority (h, m, l)
        
                // Validation check for data
                if (!data || !Array.isArray(data) || data.length === 0) {
                    return res.status(400).json({
                        error: "Invalid data format. Expected an array of objects with lo_id and priority.",
                    });
                }
        
                // Fetch relevant report_outcomes (RO) based on filters
                const [roRows] = await db.query(
                    `SELECT ro.id AS ro_id
                     FROM report_outcomes ro
                     WHERE ro.subject = ? AND ro.year = ? AND ro.id = ?`,
                    [subject, year, ro_id]
                );
        
                if (roRows.length === 0) {
                    return res.status(404).json({
                        error: "No matching RO records found for the provided filters and ro_id.",
                    });
                }
        
                // Calculate priority occurrences
                let hOccurance = 0, mOccurance = 0, lOccurance = 0;
        
                // Process input data and calculate total occurrences
                data.forEach(item => {
                    const { priority } = item;
                    if (priority === "h") {
                        hOccurance++;
                    } else if (priority === "m") {
                        mOccurance++;
                    } else if (priority === "l") {
                        lOccurance++;
                    }
                });
        
                // Calculate the total denominator
                const totalDenominator = (priorityValues.h * hOccurance) + (priorityValues.m * mOccurance) + (priorityValues.l * lOccurance);
        
                // Check if we have valid data for calculating weights
                if (totalDenominator === 0) {
                    return res.status(400).json({
                        error: "The total denominator for weight calculation is zero. Check input values.",
                    });
                }
        
                // Calculate weight for each RO and LO pair and store in ro_lo_mapping table
                const roLoMappingPromises = data.map(async (item) => {
                    const { lo_id, priority } = item;
        
                    // Calculate weight for the given priority
                    const weight = priorityValues[priority] / totalDenominator;
        
                    // Insert into ro_lo_mapping table for the provided ro_id and each LO
                    await db.query(
                        "INSERT INTO ro_lo_mapping (ro_id, lo_id, weight) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE weight = ?",
                        [ro_id, lo_id, weight, weight]
                    );
                });
        
                // Wait for all mapping insert operations to complete
                await Promise.all(roLoMappingPromises);
        
                // Calculate and store ro_scores for each student
                const roScoresPromises = roRows.map(async (roRow) => {
                    const { ro_id } = roRow;
        
                    // Fetch all LO mappings for this RO
                    const [roLoMappings] = await db.query(
                        `SELECT rl.lo_id, rl.weight, ls.student_id, ls.value
                         FROM ro_lo_mapping rl
                         INNER JOIN lo_scores ls ON rl.lo_id = ls.lo_id
                         WHERE rl.ro_id = ?`,
                        [ro_id]
                    );
        
                    // Organize data by student_id
                    const studentScores = {};
                    roLoMappings.forEach(({ student_id, weight, value }) => {
                        if (!studentScores[student_id]) {
                            studentScores[student_id] = 0;
                        }
                        studentScores[student_id] += weight * value;
                    });
        
                    // Insert or update ro_scores for each student
                    const insertPromises = Object.entries(studentScores).map(async ([student_id, ro_score]) => {
                        await db.query(
                            "INSERT INTO ro_scores (ro_id, student_id, value) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE value = ?",
                            [ro_id, student_id, ro_score, ro_score]
                        );
                    });
        
                    await Promise.all(insertPromises);
                });
        
                // Wait for all RO score calculations to complete
                await Promise.all(roScoresPromises);
        
                res.status(201).json({
                    message: "RO and LO mapping with weights saved successfully, and RO scores calculated and stored for each student.",
                });
            } catch (error) {
                console.error("Error mapping RO and LO:", error.message);
                res.status(500).json({
                    error: "Internal Server Error",
                });
            }
        });
        
//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.get("/api/lo_scores", async (req, res) => {
            try {
                // Extract student_id and lo_id from headers
                const { student_id, lo_id } = req.headers;

                // Validation check for student_id and lo_id
                if (!student_id || !lo_id) {
                    return res.status(400).json({
                        error: "Both student_id and lo_id headers are required.",
                    });
                }

                // Fetch the lo_scores based on student_id and lo_id
                const [loScores] = await db.query(
                    `SELECT ls.student_id, ls.lo_id, ls.value
                    FROM lo_scores ls
                    WHERE ls.student_id = ? AND ls.lo_id = ?`,
                    [student_id, lo_id]
                );

                if (loScores.length === 0) {
                    return res.status(404).json({
                        error: "No lo_scores found for the provided student_id and lo_id.",
                    });
                }

                // Send the response with lo_scores data
                res.status(200).json({
                    lo_scores: loScores,
                });
            } catch (error) {
                console.error("Error fetching lo_scores:", error.message);
                res.status(500).json({
                    error: "Internal Server Error",
                });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------
        app.get("/api/ro_scores", async (req, res) => {
            try {
                // Extract student_id and ro_id from headers
                const { student_id, ro_id } = req.headers;

                // Validation check for student_id and ro_id
                if (!student_id || !ro_id) {
                    return res.status(400).json({
                        error: "Both student_id and ro_id headers are required.",
                    });
                }

                // Fetch the ro_scores based on student_id and ro_id
                const [roScores] = await db.query(
                    `SELECT rs.student_id, rs.ro_id, rs.value
                    FROM ro_scores rs
                    WHERE rs.student_id = ? AND rs.ro_id = ?`,
                    [student_id, ro_id]
                );

                if (roScores.length === 0) {
                    return res.status(404).json({
                        error: "No ro_scores found for the provided student_id and ro_id.",
                    });
                }

                // Send the response with ro_scores data
                res.status(200).json({
                    ro_scores: roScores,
                });
            } catch (error) {
                console.error("Error fetching ro_scores:", error.message);
                res.status(500).json({
                    error: "Internal Server Error",
                });
            }
        });

//--------------------------------------------------------------------------------------------------------------------------------------------------

        app.listen(PORT, () => {
            console.log(`Server is running on port ${PORT}`);
        });

    } catch (err) {
        console.error("Error connecting to the database:", err.message);
    }
})();
